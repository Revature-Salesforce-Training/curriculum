////////////////////////////////////////////////////////////////////////////
//
// Name: Example Dynamic Apex
// Author: Matt Ruiz, Salesforce Team
// Created: 09/12/19
// Updated: 01/09/2022
// Description: Example of dynamically getting picklist values.
//
////////////////////////////////////////////////////////////////////////////



// In this example we want to create a data factory for cases
// and we need to generate new cases. 
// For this purpose we want to make sure we are assigning
// an assortment of all possible values for case status.
public with sharing class ExampleDynamicApex {
    
    public String caseStatus {get;set;}

    public string searchTerm {get;set;}
    
    public ExampleDynamicApex() {

    }

    // This method simply hardcodes the values
    // Should they ever change, the code will 
    // either break or be limited in its options 
    // to those hardcoded in.
    public void NonDynamic(Integer numToMake){
        List<Case> caseList = new List<Case>();
        for(integer i =0; 0<numToMake; i++){
            Case newCase = new Case();
            newCase.Origin = 'Web';
            integer status = 1;
            if(status == 1){
                newCase.status = 'New';
                caseList.add(newCase);
                status=2;
            }else if(status == 2){
                newCase.status = 'Working';
                caseList.add(newCase);
                status=3;
            }else if(status == 3){
                newCase.status = 'Escalated';
                caseList.add(newCase);
                status=4;
            }else{
                newCase.status = 'Closed';
                caseList.add(newCase);
                status=1;
            }
        }
        insert caseList;

    }

    // This method is more dynamic, but still critically flawed.
    // We are potentially getting many possible status, but we 
    // don't know that every status has an existing case to query.
    public void semidynamic(Integer numToMake){
        List<Case> caseList = [SELECT status FROM case];
        list<Case> insertList = new List<Case>();
        Set<String> statusValues = new Set<String>();

        for(Case c:caseList){
            statusValues.add(c.status);
        }

        List<String> statusList = new List<String>();
        statusList.addAll(statusValues);
        
        while(insertList.size()<numToMake){
            for(integer i = 0; i<statusList.size(); i++){
                if(insertList.size()<numToMake){
                    Case newCase = new Case(status = statusList[i], origin = 'Web');
                    insertList.add(newCase);
                }
            }
        }
        insert insertList;
    }

    // So how do we do this in a dynamic way?
    public void dynamic(Integer num){
        // We need a list to store our cases in.
        List<Case> caseList = new List<Case>();
        // We want to get the describe information, this contains information on
        // the field, which is a picklist.
        Schema.DescribeFieldResult fieldResult = case.status.getdescribe();
        system.debug(fieldResult);
        // Now that we have the information about the field, let us get the
        // specific information we want, in this case the picklist values.
        // Note: Picklist values have a label and a value, so in this case
        // we need to store the information as a Schema.PicklistEntry
        // which will contain both the label and values.
        List<Schema.PicklistEntry> picklistValues = fieldResult.getPicklistValues();
        for(integer i = 0; i < num; i++){
            // Now we are going to loop through all of the values, and for 
            // each one insert a new case that has that value.
            for(Schema.PicklistEntry value : picklistValues){
                if(i < num) {
					Case newCase = new Case();
					// Now we need to assign the value to the case we are making.
					// We cannot simply work directly with the Schema.PicklistEntry,
					// instead we use the getValue method to get the string value of
					// the picklist value. We could also use getLabel() to get the
					// label instead should we want it.
					newCase.status = value.getValue();
					newCase.Origin = 'Web';
					caseList.add(newCase);
					i++;
				}
            }
        }
        insert caseList;
    }
	
	
	/* 
	
	another example of dynamically getting picklist values, here we use dot notation
	
	First, we use the Account static variable of the Schema.SObjectType class (which has a member 
	variable for each standard and custom object). When we call this variable through dot notation, 
	it returns a DescribeSObjectResult object.

	The fields property of this object has a reference to each of our Account fields, so we access the 
	AccountSource field through dot notation to get the corresponding DescribeFieldResult object. 
	Finally, we use the getPicklistValues() method of the DescribeFieldResult class, which returns a 
	list of Schema.PicklistEntry objects.

	Although they are made from two different classes, Schema.PicklistEntry and SelectOption objects 
	both have values and labels, so we use a for loop to populate the value and label of an option with 
	the same properties from an element of our list of picklist values.
	
	*/
	
	public class AccountController {
		public Account acc {get;set;}
		public List<SelectOption> accSources {get{
			List<Schema.PicklistEntry> sources = 
				Schema.SObjectType.Account.fields.AccountSource.getPicklistValues();
			accSources = new List<SelectOption>();
			for(Schema.PicklistEntry pe : sources){
				accSources.add(new SelectOption(pe.getValue(), pe.getLabel()));
			}
			return accSources;
		}set;}

		public AccountController(){
			this.acc = new Account();
		}

		public void saveAccount(){
			insert this.acc;
		}
	}

    // Dynamic Queries
    /*
    // Instead of using our square brackets to hard code a query, we can take advantage 
    // of variable binding and the database and search classes.
    // database.query and search.query allows us to pass in a string and have that string
    // interpretted as a query. This allows us to dynamically construct a string and then
    // query the information.
    */
    public void DynamicSOQL(){
	
		// Here we can use variable binding to change the query.
        string newS = 'John Smith';
        List<Account> accList = [SELECT name FROM account WHERE name LIKE :newS];
        
		//here we use the database.query method for the same functionality
		String s = 'SELECT name FROM account';
		if (userInput) {
			s += ' WHERE name LIKE ' + String.escapeSingleQuotes(userInput);
		}
		List<Account> accList2 = database.query(s);
        
    }

    public void DynamicSOSL(){
	
        String s = 'FIND ' + String.escapeSingleQuotes(userInput) + ' RETURNING Contact(Name, Number)';
        List<List<sObject>> cons = search.query(s);
		
		//variable binding is available with SOSL as well. 
    }

}